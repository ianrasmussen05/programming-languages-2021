# Discussion Topics 

Thanks to everybody who contributed links (Sam Balco, Chris Chang, Pablo Labbate, Matt Raymond, Lucas Torti, ... ).

## New for 2021: 

- Formal Methods at Facebook:
  - [Applying Formal Verification to Microkernel IPC at Meta](https://www.cs.cornell.edu/~noamz/files/pubs/cpp22.pdf), 2022.
  - [Finding Real Bugs in Big Programs with Incorrectness Logic](http://www0.cs.ucl.ac.uk/staff/p.ohearn/RealBigDraft.pdf), 2021.
- Formal Methods at Amazon:
  - Byron Cook: [On the Business of Proof ](https://www.youtube.com/watch?v=g-DH_b5bFd4), 2021.
- [Recursion in Programming - Full Course](https://www.youtube.com/watch?v=IJDJ0kBx2LM&t=834s).
- Are the following Turing complete? [Minecraft](https://www.youtube.com/watch?v=1X21HQphy6I), [Power Point](https://www.youtube.com/watch?v=uNjxe8ShM-8), [LaTeX](https://stackoverflow.com/questions/2968411/ive-heard-that-latex-is-turing-complete-are-there-any-programs-written-in-late), [Excel](https://visualstudiomagazine.com/articles/2021/01/27/excel-lambda.aspx), ... [surprisingly Turing complete](https://www.gwern.net/Turing-complete) ... [accidentally Turing complete](http://beza1e1.tuxen.de/articles/accidentally_turing_complete.html) ... [Wang tiles](https://grahamshawcross.com/2012/10/12/wang-tiles-and-turing-machines/) ... [even more links](https://news.ycombinator.com/item?id=16383072) ...
- Transcribing music as a parsing problem, see Example 1 in [Symbolic Weighted Language Models, Quantitative Parsing and Verification over Infinite Alphabets](https://hal.inria.fr/hal-03380268/document). 
- Byron Cook: [Formal Reasoning about the Security of Amazon Web Services](https://www.youtube.com/watch?v=JfjLKBO27nw).
- Peter O'Hearn on how to solve unsolvable problems: [Facebook's Code Checker](https://www.youtube.com/watch?v=tKR2UZdRpV0). See also the lecture [Continuous Reasoning: Scaling the impact of formal methods](https://www.youtube.com/watch?v=HW5Zq1TsQqU) and the article [Scaling Static Analyses at Facebook](https://dl.acm.org/doi/pdf/10.1145/3338112), which give valuable insights in the continuous integration process at a big software company. Of particular importance is the concept of *diff time continuous reasoning*.
- [Who invented video games?](https://theconversation.com/who-invented-video-games-169792) Note that Christopher Strachey is one of the pioneers of programming languages.
- [The Web's Freedom Fallacy](https://ez.substack.com/p/the-webs-freedom-fallacy). If you are interested in blockchain, decentralised social media and their intersection with law this article has some interesting links to follow.  
- [Facebook fights spam with Haskell](https://engineering.fb.com/2015/06/26/security/fighting-spam-with-haskell/). "The Haskell-powered Sigma now runs in production, serving more than one million requests per second. [...] We haven’t seen any crashes in either the Haskell runtime or the Haskell code itself across our whole fleet."
- [How to make a bad programming language](https://www.youtube.com/watch?v=2mnYf7L7Amw).
- Erik Meijer on [The Programming Language World Today](https://www.youtube.com/watch?v=NKeHrApPWlo#t=14m55s), 2017.
- John Hughes in Computerphile on [Functional Programming & Haskell](https://www.youtube.com/watch?v=LnX3B9oaKzw).
- Controlling Complexity in Software Engineering: [Brian Beckman: Don't fear the Monad](https://www.youtube.com/watch?v=ZhuHCtR3xq8#t=16m26s).
- An [interpreter](https://github.com/Hirrolot/metalang99/blob/master/examples/lambda_calculus.c) for lambda calculus using the C preprocessor.
- Bob Coecke on [Quantum Natural Language Processing](https://www.youtube.com/watch?v=5YZG96t8SLQ), [Bob Coecke and Stephen Wolfram](https://www.youtube.com/watch?v=8CUTXaGqvSQ&list=PLxn-kpJHbPx2xsLWXrRuZLFc9RxLhP42s&index=3).
-  Douglas Rushkoff's [Survival of the Richest](https://medium.com/s/playback/douglas-rushkoff-survival-of-the-richest-eac5601b935b) became quite well-known, but I didn't know that his podcast mentions Haskell. The line is "I am more of the technology world's old country doctor ... I don't know the actual edge things ... I don't know how to program in Haskell". 
- [DEEP LEARNING’S DIMINISHING RETURNS: The cost of improvement is becoming unsustainable](https://spectrum.ieee.org/deep-learning-computational-cost).  
- [NLP and Film](https://www.theatlantic.com/technology/archive/2016/07/the-six-main-arcs-in-storytelling-identified-by-a-computer/490733/). 
- [CompilerGym: Robust, Performant Compiler Optimization Environments for AI Research
](https://deepai.org/publication/compilergym-robust-performant-compiler-optimization-environments-for-ai-research). On how to apply machine learning to compiler optimization.
- Pull requests and open source software: [How To Rapidly Improve At Any Programming Language](https://www.cbui.dev/how-to-rapidly-improve-at-any-programming-language/). "read other people’s PRs and learn from the comments the maintainer and others leave"
- [Building apps in minutes, not months](https://alexanderobenauer.com/labnotes/001/).
- Some webpages that illustrate the recent advances in AI: - Language: [New Age Bullshit Generator](https://sebpearce.com/bullshit/); Text and Images: [DALL·E](https://openai.com/blog/dall-e/); Pictures of People: [thispersondoesnotexist](https://thispersondoesnotexist.com/).
- Writing code in natural language: [OpenAI Codex Live Demo](https://www.youtube.com/watch?v=SGUCcjHTmGY#t=13m8s).
- Many fundamental ideas in programming languages were first explored in **Lisp**. Here are some interesting reads. [How Lisp Became God's Own Programming Language](https://twobithistory.org/2018/10/14/lisp.html). John McCarthy's original article [Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I](http://jmc.stanford.edu/articles/recursive/recursive.pdf) and Paul Graham's [The Roots of Lisp](http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf). Steele and Sussman's [The Art of the Interpreter](http://bitsavers.informatik.uni-stuttgart.de/pdf/mit/ai/aim/AIM-453.pdf) shows how to write interpreters in Lisp. [The Revenge of Lisp](https://renato.athaydes.com/posts/revenge_of_lisp.html). 
- [The Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/).
- [We need a safer systems programming language](https://msrc-blog.microsoft.com/2019/07/18/we-need-a-safer-systems-programming-language/). Quote: "*whenever possible software should eventually be moved to a completely memory-safe language [...] If there are legitimate reasons for needing the speed, control and predictability of a language like C++, see if you can move to a systems-level programming language that is memory safe*". The next post advertising Rust is also interesting. If you want to see how these problems inspire current research in programming languages look for example at [Project Verona](https://github.com/microsoft/verona/blob/master/docs/faq.md).
(Btw, I found this article linked in a [blog by Edward Snowden](https://edwardsnowden.substack.com/p/ns-oh-god-how-is-this-legal)  who is always worth reading when it comes to the topics of privacy, surveillence and security.)
- [10 Papers Every Developer Should Read](https://michaelfeathers.silvrback.com/10-papers-every-developer-should-read-at-least-twice) ... these papers could make an interesting discussion.

## From 2020 (but still of interest):

None of this is required reading, but all of it is part of the wider landscape in which this course is situated. Many of these links are to talks, videos, articles and blogs that do not represent carefully researched peer-reviewed authoritative expert consensus. Do not take opinions for granted but as an invitation to start a discussion.

(And thanks to everybody who contributed links.)

- [AsciiDots](https://esolangs.org/wiki/AsciiDots). "AsciiDots is an esoteric programming language based on ascii art." I didn't look into this but I like the idea of developing small programming languages not so much for a practical purpose but rather as a computer-art project. Any ideas? Get in touch ...

- [Contravariant logging](https://www.youtube.com/watch?v=qzOQOmmkKEM&list=PLxxF72uPfQVTfDksvV4KPV5CxKnf0d_X3#t=25m20s). Logging can be pain ("low to weight ratio"). Starting at 25:23, this talk explains how to do logging with a minimal interface. The basic explanation of how to do "simple oneline tracing" is finished by 31:47. 

- Why does GoLang have objects but no inheritance?

- What makes a programming language successful? This question is discussed in the video [Why Isn't Functional Programming the Norm?](https://www.youtube.com/watch?v=QyJZzq0v7Z4) He concludes with several arguments why FP might be the norm in the future for example searching for books on ["functional programming in"](https://www.amazon.com/s?k=%22functional+programming+in%22&ref=nb_sb_noss_2) suggests that many imperative and OO languages are keen on jumping on the FP train. What do you think?

- Domain Specific Languages (DSLs) play an increasing role in industry. Haskell is a good language to develop DSLs. For an example see [Ivory](https://raw.githubusercontent.com/GaloisInc/smaccmpilot-experiencereport/master/embedded-experience.pdf).

- The [No-Code Software Revolution](https://medium.com/inc./welcome-to-the-no-code-software-revolution-6b75ee967df7). Will building apps without writing code change what we understand by "programming language"?

- [rise4fun](https://rise4fun.com/) has a long list of **software engineering tools** for program analysis and verification that you can run in your webbrowser.

- **Unison** is a new programming language based on the idea of [content-addressed code](https://www.unisonweb.org/docs/tour). Search the linked tour for "functional" to see why it is important for Unison to be a pure functional programming language. I only worked through the tour sofar, but it looks very interesting.

- Charles Scalfani on Haskell: He writes from the point of view of a software engineer who had to learn Haskell the hard way. I first came across his article [Goodbye, Object Oriented Programming](https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53#.p6vn7xvdj). His [more recent articles](https://medium.com/@cscalfani) contain more lessons about how and why to learn Haskell. Could be a starting point to assess how the pros and cons of different programming languages and paradigms are discussed by software developpers. 

- Terence Tao: [Compactness and contradiction](https://terrytao.files.wordpress.com/2011/06/blog-book.pdf). Tao is one of the leading mathematicians of his generation. Nevertheless, Chapter 1 on "Logic and foundations" of this book is quite accessible to a reader with background in computing and/or logic and it touches on many topics that crop up in this course. Highly recommended to everybody with a taste for mathematics. I found Sections 1.11 about vagueness and 1.12 about a computational perspective on set theory particularly insightful. Section 1.4 on "Stable implications" is closely related to a favourite topic of mine, namely "Mathematics as a programming language".

- [Turing Incomplete Languages](http://neilmitchell.blogspot.com/2020/11/turing-incomplete-languages.html). This blog illustrates a general topic: If you want a language that can express important ideas easily, you can also use this language to express rubbish easily. If you want to limit language so that it becomes impossible to express rubbish, good ideas become also more difficult to express. And then, after a while, you notice that you can still write rubbish in the restricted language anyway. (Sam Griffin in the comments has a more nuanced view on this.) So you end up making the language expressive again (unless there is a specific technical reason not to do so, such as efficient automatization (see also the last sentence of Chapter 1 of Tao's book referenced above)). Btw, in this context one should recall Turing's theorem: Every language that allows us to express all terminating programs must necessarily allow us to write non-terminating programs. One thing one should add to the article (but see the comments), is that there are actually languages, known as type theories, with powerful recursion principles in which all programmable functions do terminate. 

- **Programming Languages for Data Science and AI:**   
  - [Programmatically interpretable reinforcement learning](https://blog.acolyer.org/2020/01/15/programmatically-interpretable-reinforcement-learning/). The main idea is to improve interpretability by learning expressions in a domain specific language representing expert knowledge. Could that be combined with theorem proving as in the approach of [Ganesalingam and Gowers](https://arxiv.org/pdf/1309.4501.pdf)?
  - Differential Programming and Probabilistic Programming Languages are two quickly growing fields. I plan to add references over time (but I might forget):
    - Conal Elliott investigate in [Efficient automatic differentiation made easy via category theory](https://www.youtube.com/watch?v=17gfCTnw6uE) whether **differentiation of functions can be added  as an operation to functional programming languages such as Haskell**. In [A Functional Reboot for Deep Learning](https://github.com/conal/talk-2018-deep-learning-rebooted#readme) he goes further and argues that we should program machine learning algorithms in a programming language that does have differentiation but *hides neural networks, layers, and backpropagation as implementation details*. This might allow us, for example, to use a larger variety of functions for learning and thus reduce the complexity of the neural networks. A hint at the technicalities is given after [23:45](https://www.youtube.com/watch?v=Ns3DxUeCvRg#t=23m45s).
    - Vakar, Kammar, Staton: [A Domain Theory for Statistical Probabilistic Programming](https://arxiv.org/pdf/1811.04196.pdf). We do not cover enough theory in the course to understand this paper. But reading the introduction shows that the basic principles we will learn about underpin cutting edge research on novel programming languages that allows us not just to do numerical calculations and simulations but to **directly build and manipulate the underlying statistical models**. 

- Video: [Modelling Pandemics in Julia](https://www.youtube.com/watch?v=7zr2qnud4XM&feature=youtu.be) features many of the topics that appear in our course. 


- [Lego Turing Machine](https://vimeo.com/44202270)

- **Multi-Paradigm Languages**: 
  - [Julia](https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/) may well be on the way to replace Python as the language for scientific computing. 
  - [Scala](https://data-flair.training/blogs/why-scala/) continues the success of Java but adds FP features such as higher-order functions, algebraic data types and pattern matching. 
  -  [Rust]() builds on the success of C, but adds features of modern languages including FP. Rust's concept of [Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) strikes a balance between C-style memory allocation and Java-style garbage collection. This ideas is related to [linear type systems](https://arxiv.org/pdf/1710.09756). For more on how Rust combines imperative with functional features see eg the blog [Is Rust a functional programming language?](https://www.fpcomplete.com/blog/2018/10/is-rust-functional/).

  - ...

- Comparing different programming paradigms. There is a raging debate about the pros and cons of different programming paradigms. Reading widely to get a lot of different views is recommended. Often the comments are the most interesting part. Here are some entry points. [Was object-oriented programming a failure?](https://www.quora.com/Was-object-oriented-programming-a-failure/answer/Michael-O-Church?srid=wk4L) ...

- [Compiling Lisp to JavaScript From Scratch in 350 LOC](https://gilmi.xyz/blog/post/2016/10/14/lisp-to-js) 
